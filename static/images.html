<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <script src="./mp4box.all.min.js"></script>
  <title>Load mp4</title>
</head>

<body>
  <h1>Load mp4</h1>

  <input type="file" accept="video/mp4" onchange="start(this.files[0])" multiple>
  <button onclick="stop()">Stop</button> infps:<span id="infps"></span> outfps:<span id="outfps"></span>
  <div id="content">
  </div>

  <script type="module">
    
    class MP4PullDemuxer  {
      constructor(fileUri) {
        this.fileUri = fileUri;
      }

      async initialize() {
        this.source = new MP4Source(this.fileUri);
        this.readySamples = [];
        this._pending_read_resolver = null;

        await this._tracksReady();
        this._selectTrack(this.videoTrack);
      }

      getDecoderConfig() {
          return {
            // Browser doesn't support parsing full vp8 codec (eg: `vp08.00.41.08`),
            // they only support `vp8`.
            codec: this.videoTrack.codec.startsWith('vp08') ? 'vp8' : this.videoTrack.codec,
            displayWidth: this.videoTrack.track_width,
            displayHeight: this.videoTrack.track_height,
            description: this._getDescription(this.source.getDescriptionBox())
          }
      }

      async getNextChunk() {
        let sample = await this._readSample();
        const type = sample.is_sync ? "key" : "delta";
        const pts_us = (sample.cts * 1000000) / sample.timescale;
        const duration_us = (sample.duration * 1000000) / sample.timescale;
        return new EncodedVideoChunk({
          type: type,
          timestamp: pts_us,
          duration: duration_us,
          data: sample.data
        });
      }

      _getDescription(descriptionBox) {
        const stream = new DataStream(undefined, 0, DataStream.BIG_ENDIAN);
        descriptionBox.write(stream);
        return new Uint8Array(stream.buffer, 8);  // Remove the box header.
      }

      async _tracksReady() {
        let info = await this.source.getInfo();
        this.videoTrack = info.videoTracks[0];
      }

      _selectTrack(track) {
        console.assert(!this.selectedTrack, "changing tracks is not implemented");
        this.selectedTrack = track;
        this.source.selectTrack(track);
      }

      async _readSample() {
        console.assert(this.selectedTrack);
        console.assert(!this._pending_read_resolver);

        if (this.readySamples.length) {
          return Promise.resolve(this.readySamples.shift());
        } else{
          let promise = new Promise((resolver) => this._pending_read_resolver = resolver);
          console.assert(this._pending_read_resolver);
          this.source.start(this._onSamples.bind(this));
          return promise;
        }
      }

      _onSamples(samples) {
        this.readySamples.push(...samples);

        let firstSampleTime = samples[0].cts * 1000000 / samples[0].timescale ;
        console.log(`adding new ${samples.length} samples (first = ${firstSampleTime}). total = ${this.readySamples.length}`);

        if (this._pending_read_resolver) {
          this._pending_read_resolver(this.readySamples.shift());
          this._pending_read_resolver = null;
        }
      }
    }

    class MP4Source {
      constructor(uri) {
        this.file = MP4Box.createFile();
        this.file.onError = console.error.bind(console);
        this.file.onReady = this.onReady.bind(this);
        this.file.onSamples = this.onSamples.bind(this);

        console.log('fetching file');
        fetch(uri).then(response => {
          console.log('fetch responded');
          const reader = response.body.getReader();
          let offset = 0;
          let mp4File = this.file;

          function appendBuffers({done, value}) {
            if(done) {
              mp4File.flush();
            } else {
              let buf = value.buffer;
              buf.fileStart = offset;
              offset += buf.byteLength;
              mp4File.appendBuffer(buf);
              
              return reader.read().then(appendBuffers);
            }
          }

          return reader.read().then(appendBuffers);
        })

        this.info = null;
        this._info_resolver = null;
      }

      onReady(info) {
        this.info = info;

        if (this._info_resolver) {
          this._info_resolver(info);
          this._info_resolver = null;
        }
      }

      getInfo() {
        if (this.info) {
          return Promise.resolve(this.info);
        } else {
          return new Promise((resolver) => this._info_resolver = resolver);
        }
      }

      getDescriptionBox() {
        // TODO: make sure this is coming from the right track.
        const entry = this.file.moov.traks[0].mdia.minf.stbl.stsd.entries[0];
        const box = entry.avcC || entry.hvcC || entry.vpcC || entry.av1C;
        if (!box) {
          throw new Error("avcC, hvcC, vpcC, or av1C box not found!");
        }
        return box;
      }

      selectTrack(track) {
        console.log('selecting track %d', track.id);
        this.file.setExtractionOptions(track.id);
      }

      start(onSamples) {
        this._onSamples = onSamples;
        this.file.start();
      }

      stop() {
        this.file.stop();
      }

      onSamples(track_id, ref, samples) {
        this._onSamples(samples);
      }
    }

    fetch("/models")
      .then(r => r.json())
      .then(r => window.model = r[0]);

    window.start = async function (file) {
      let videoUrl = URL.createObjectURL(file);

      let demuxer = new MP4PullDemuxer(videoUrl);
      await demuxer.initialize();
      const config = demuxer.getDecoderConfig();
      console.log(config);
      
      let decoder = new VideoDecoder({
        output: frame => {
          const canvas = document.createElement("canvas");
          canvas.width = config.displayWidth;
          canvas.height = config.displayHeight;
          canvas.getContext('2d').drawImage(frame, 0, 0);
          content.appendChild(canvas);
          frame.close();
        },
        error: () => decoder.close(),
      });

      let support = await VideoDecoder.isConfigSupported(config);
      console.assert(support.supported);
      decoder.configure(config);

      while (decoder.state != "closed") {
          let chunk = await demuxer.getNextChunk();
          decoder.decode(chunk);  
      }
      console.log("done");
    }
  </script>

</html>
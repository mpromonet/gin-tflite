<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <script src="./tools.js"></script>
  <script src="./mp4box.all.min.js"></script>
  <title>Load mp4 with webcodec</title>
</head>

<body>
  <input type="file" accept="video/mp4" onchange="start(this.files[0])">
  <div id="content">
  </div>

  <script type="module">
    
    class MP4PullDemuxer  {
      constructor(fileUri) {
        this.fileUri = fileUri;
      }

      async initialize() {
        this.source = new MP4Source(this.fileUri);
        this.readySamples = [];
        this._pending_read_resolver = null;

        const info = await this.source.getInfo();
        this.videoTrack = info.videoTracks[0];

        this.source.selectTrack(this.videoTrack);
      }

      getDecoderConfig() {
          return {
            // Browser doesn't support parsing full vp8 codec (eg: `vp08.00.41.08`),
            // they only support `vp8`.
            codec: this.videoTrack.codec.startsWith('vp08') ? 'vp8' : this.videoTrack.codec,
            displayWidth: this.videoTrack.track_width,
            displayHeight: this.videoTrack.track_height,
            description: this._getDescription(this.source.getDescriptionBox())
          }
      }

      async getNextChunk() {
        let sample = await this._readSample();
        const type = sample.is_sync ? "key" : "delta";
        const pts_us = (sample.cts * 1000000) / sample.timescale;
        const duration_us = (sample.duration * 1000000) / sample.timescale;
        return new EncodedVideoChunk({
          type: type,
          timestamp: pts_us,
          duration: duration_us,
          data: sample.data
        });
      }

      _getDescription(descriptionBox) {
        const stream = new DataStream(undefined, 0, DataStream.BIG_ENDIAN);
        descriptionBox.write(stream);
        return new Uint8Array(stream.buffer, 8);  // Remove the box header.
      }

      async _readSample() {
        console.assert(!this._pending_read_resolver);

        if (this.readySamples.length) {
          return Promise.resolve(this.readySamples.shift());
        } else{
          let promise = new Promise((resolver) => this._pending_read_resolver = resolver);
          console.assert(this._pending_read_resolver);
          this.source.start(this._onSamples.bind(this));
          return promise;
        }
      }

      _onSamples(samples) {
        this.readySamples.push(...samples);
        console.log(`adding new ${samples.length} samples. total = ${this.readySamples.length}`);

        if (this._pending_read_resolver) {
          this._pending_read_resolver(this.readySamples.shift());
          this._pending_read_resolver = null;
        }
      }
    }

    class MP4Source {
      constructor(uri) {
        this.file = MP4Box.createFile();
        this.file.onError = console.error.bind(console);
        this.file.onReady = this.onReady.bind(this);
        this.file.onSamples = this.onSamples.bind(this);

        console.log('fetching file');
        fetch(uri).then(response => {
          console.log('fetch responded');
          const reader = response.body.getReader();
          let offset = 0;
          let mp4File = this.file;

          function appendBuffers({done, value}) {
            if(done) {
              mp4File.flush();
            } else {
              let buf = value.buffer;
              buf.fileStart = offset;
              offset += buf.byteLength;
              mp4File.appendBuffer(buf);
              
              return reader.read().then(appendBuffers);
            }
          }
          return reader.read().then(appendBuffers);
        })

        this.info = null;
        this._info_resolver = null;
      }

      onReady(info) {
        this.info = info;

        if (this._info_resolver) {
          this._info_resolver(info);
          this._info_resolver = null;
        }
      }

      getInfo() {
        if (this.info) {
          return Promise.resolve(this.info);
        } else {
          return new Promise((resolver) => this._info_resolver = resolver);
        }
      }

      getDescriptionBox() {
        // TODO: make sure this is coming from the right track.
        const entry = this.file.moov.traks[0].mdia.minf.stbl.stsd.entries[0];
        const box = entry.avcC || entry.hvcC || entry.vpcC || entry.av1C;
        if (!box) {
          throw new Error("avcC, hvcC, vpcC, or av1C box not found!");
        }
        return box;
      }

      selectTrack(track) {
        console.log('selecting track %d', track.id);
        this.file.setExtractionOptions(track.id);
      }

      start(onSamples) {
        this._onSamples = onSamples;
        this.file.start();
      }

      stop() {
        this.file.stop();
      }

      onSamples(track_id, ref, samples) {
        this._onSamples(samples);
      }
    }

    fetch("/models")
      .then(r => r.json())
      .then(r => window.model = r[0]);

    window.start = async function (file) {
      const videoUrl = URL.createObjectURL(file);

      const demuxer = new MP4PullDemuxer(videoUrl);
      await demuxer.initialize();
      const config = demuxer.getDecoderConfig();
      console.log(config);
      let support = await VideoDecoder.isConfigSupported(config);
      console.assert(support.supported);
            
      const decoder = new VideoDecoder({
        output: frame => {
          const canvas = document.createElement("canvas");
          canvas.width = config.displayWidth;
          canvas.height = config.displayHeight;
          const context = canvas.getContext('2d');
          context.drawImage(frame, 0, 0);
          frame.close();

          const dataurl = canvas.toDataURL("image/jpeg");
          fetch(dataurl) 
            .then(r => r.blob())
            .then(blob => {
              fetch(`/invoke/${window.model}`, { method: 'POST', body: blob })
                .then(r => r.json())
                .then(data => drawOverlay(context, data))
                .catch((err) => console.log(err))
                .finally(() => content.appendChild(canvas));
            });
        },
        error: () => decoder.close(),
      });
      decoder.configure(config);

      let cnt=0;
      while ( (cnt++ < demuxer.videoTrack.nb_samples) && (decoder.state != "closed") ) {
          let chunk = await demuxer.getNextChunk();
          decoder.decode(chunk);  
      }
      console.log(`${cnt} frames decoded`);
    }
  </script>

</html>